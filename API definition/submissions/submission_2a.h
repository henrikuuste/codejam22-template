#include <eigen3/Eigen/Dense>
#include <iostream>
#include <memory>
#include <utility>
#include <vector>
namespace cjpp /* CodeJam PathPlanner */
{
/**
 * Result of the planner if a valid path can be found or not.
 *
 */
enum Result {
  SOLVED,           // A solution was found
  UNSOLVED,         // No solution was found
  INVLMAPFORMAT,    // Map is null
  LONGPATHSOLVED,   // A solution was found but the lenght of the path is longer than the threshold
  LONGPATHUNSOLVED, // No solution was found even beyond the path threshold was included in the
                    // search
  OUTOFMAP,         // Given start or end coordinates out of the map
  INVLCOOR          // Coordinates are null
};
// using MapCoordinate = std::pair<int, int>;
using MapCoordinate = Eigen::Vector2f;
using Path          = std::vector<MapCoordinate>;
using heuristic     = float (*)(MapCoordinate, MapCoordinate);

/**
 * This class is a base class for any kind of path planner algorithm. It has one function for
 * solving a map provided It returns a result structure.
 *
 */

class basePlanner {
public:
  struct pathPlannerResult;

  virtual pathPlannerResult solver(const simpleMap &map, MapCoordinate startPoint,
                                   MapCoordinate endPoint, int obstacleThreshold = 0,
                                   std::size_t maxPathLength = 0, bool cancelAtMaximum = false) = 0;
};

/**
 * This class uses A* algorithm. It uses an original virtual function for solving the map and
 * another overloaded function to solve the map with an additional setting. It then calls the actual
 * astar solver function.
 *
 */

class astarPlanner : basePlanner {

private:
  void astar(const simpleMap &map, pathPlannerResult &pathPlannerResult, int obstacleThreshold,
             heuristic heuristic, std::size_t maxPathLength, bool cancelAtMaximum);
  static float defaultHeuristic(MapCoordinate startPoint, MapCoordinate endPoint);

public:
  pathPlannerResult solver(const simpleMap &map, MapCoordinate startPoint, MapCoordinate endPoint,
                           int obstacleThreshold = 0, std::size_t maxPathLength = 0,
                           bool cancelAtMaximum = false);
  pathPlannerResult solver(const simpleMap &map, MapCoordinate startPoint, MapCoordinate endPoint,
                           heuristic heuristic, int obstacleThreshold = 0,
                           std::size_t maxPathLength = 0, bool cancelAtMaximum = false);
};
/**
 * A simple map class which holds a map in matrix format and its dimensions.
 * At the moment the map consists of integer coordinates only.
 */
class simpleMap {
  simpleMap(std::size_t rows, std::size_t cols)
      : map(std::make_shared<Eigen::MatrixXd>(rows, cols)), Y(map->rows()), X(map->cols()),
        minCost_(map->minCoeff()), maxCost_(map->maxCoeff()) {}

public:
  const int X; // x dimension of the map
  const int Y; // y dimension of the map
  const std::shared_ptr<Eigen::MatrixXd> map;
  const int minCost_; // Min cost value in the map
  const int maxCost_; // Max cost value in the map
};

} // namespace cjpp

using pPR = cjpp::basePlanner::pathPlannerResult;

/**
 * A struct to hold information about the result of our planner. Regardless the success status, the
 planner
 * returns this struct. If the result is UNSOLVED, paths will be empty.
 *

 */
class cjpp::basePlanner::pathPlannerResult {
public:
  MapCoordinate startPoint() { return startPoint_; }
  MapCoordinate endPoint() { return endPoint_; }
  Path paths() { return paths_; }
  Result result() { return result_; }

  MapCoordinate setStartPoint(MapCoordinate sp) { startPoint_ = sp; }
  MapCoordinate setEndPoint(MapCoordinate ep) { endPoint_ = ep; }
  Path setPaths(Path p) { paths_ = p; }
  Result setResult(Result r) { result_ = r; }

private:
  MapCoordinate startPoint_; // The starting point of the planning
  MapCoordinate endPoint_;   // The destination point of the planning
  Path paths_;               // Points of the solved path
  Result result_;            // Success result of the path planning, if there is any valid path
};

/**
 * @brief
 *
 * @param map A cost map generated by mapGenerator class
 * @param startPoint Starting point of the vehicle
 * @param endPoint Destination point of the vehicle
 * @param obstacleThreshold A fast way of testing some costs as obstacles without
 * changing/regenerating the cost map
 * @param maxPathLenghth The maximum lenght a solution path can be
 * @param cancelAtMaximum Keep searching for a solution even it exceeds the maxPathLength
 * @return pPR Returns a class with success status, solved path(s), start and end points.
 *
 * TEST1 : Start point within the range of the map
 * TEST2 : End point within the range of the map
 * TEST3 : Map is null
 * TEST4 : Start point is null
 * TEST5 : End point is null
 * TEST6 : Obstacle threshhold is too small
 * TEST7 : Obstacle threshhold is too big
 * TEST8 : maxPathLength is too small
 * TEST8 : maxPathLength is too big
 * TEST8 : maxPathLength is moderately small cancelAtMaximum = false
 * TEST8 : maxPathLength is moderately small cancelAtMaximum = true
 * TEST8 : maxPathLength is moderately small cancelAtMaximum = false
 * TEST8 : maxPathLength is moderately big cancelAtMaximum = true
 *
 */
pPR cjpp::astarPlanner::solver(const simpleMap &map, MapCoordinate startPoint,
                               MapCoordinate endPoint, int obstacleThreshold = 0,
                               std::size_t maxPathLength = 0, bool cancelAtMaximum = false) {
  return astarPlanner::solver(map, startPoint, endPoint, &defaultHeuristic, obstacleThreshold,
                              maxPathLength);
}
/**
 * @brief
 *
 * @param map A cost map generated by mapGenerator class
 * @param startPoint Starting point of the vehicle
 * @param endPoint Destination point of the vehicle
 * @param obstacleThreshold A fast way of testing some costs as obstacles without
 * changing/regenerating the cost map
 * @param maxPathLenghth The maximum lenght a solution path can be
 * @param cancelAtMaximum Keep searching for a solution even it exceeds the maxPathLength
 * @param heuristic Use a custom heuristic method, float(MapCoordinate,MapCoordinate)
 * @return pPR Returns a class with success status, solved path(s), start and end points.
 */
pPR cjpp::astarPlanner::solver(const simpleMap &map, MapCoordinate startPoint,
                               MapCoordinate endPoint, heuristic heuristic,
                               int obstacleThreshold = 0, std::size_t maxPathLength = 0,
                               bool cancelAtMaximum = false) {

  pathPlannerResult result;
  result.setStartPoint(startPoint);
  result.setEndPoint(endPoint);

  if (map.map == nullptr || map.map->size() == 0) {
    result.setResult(Result::INVLMAPFORMAT);
    return;
  } else if (startPoint.x() < 0 || startPoint.x() >= map.X || startPoint.y() < 0 ||
             startPoint.y() >= map.Y) {
    result.setResult(Result::OUTOFMAP);
    return;
  } else if (startPoint.size() == 0 || endPoint.size() == 0) {
    result.setResult(Result::INVLCOOR);
    return;
  }

  astar(map, result, obstacleThreshold, heuristic, maxPathLength, cancelAtMaximum);
  return result;
}
/**
 * @brief
 *
 * @param map A cost map generated by mapGenerator class
 * @param pathPlannerResult At least one valid path found
 * @param obstacleThreshold A fast way of testing some costs as obstacles without
 * changing/regenerating the cost map
 * @param heuristic Use a custom heuristic method, float(MapCoordinate,MapCoordinate)
 * @param maxPathLenghth The maximum lenght a solution path can be
 * @param cancelAtMaximum Keep searching for a solution even it exceeds the maxPathLength
 */
void cjpp::astarPlanner::astar(const simpleMap &map, pathPlannerResult &pathPlannerResult,
                               int obstacleThreshold, heuristic heuristic,
                               std::size_t maxPathLength, bool cancelAtMaximum) {
  if (maxPathLength >= map.X * map.Y) {
    std::cout << "Maximum path lenght is too big. Setting it to: " << map.X * map.Y << "\n";
    maxPathLength = map.X * map.Y;
  }
  if (obstacleThreshold <= map.minCost_) {
    std::cout << "No valid path on the map. Check cost map or obstacle Threshold...\n";
    pathPlannerResult.setResult(Result::UNSOLVED);
    return;
  }
  if (obstacleThreshold >= map.maxCost_) {
    std::cout << "No obstacle found on the map. Getting the closest distance...\n";
    // Calculate hypotenuse between two points
    pathPlannerResult.setResult(Result::SOLVED);
    return;
  }
  if (maxPathLength == 0) {
    // Use heuristic function to calculate distances

    // pathPlannerResult.paths = doSomething(map.map) ;

    pathPlannerResult.setResult(Result::SOLVED);
    // or UNSOLVED if no path is found
    pathPlannerResult.setResult(Result::UNSOLVED);
  } else if (maxPathLength > 0 && cancelAtMaximum == false) {
    // Use heuristic function to calculate distances

    // pathPlannerResult.paths = doSomething(map.map) ;

    pathPlannerResult.setResult(Result::SOLVED);
    // or UNSOLVED if no path is found
    pathPlannerResult.setResult(Result::UNSOLVED);
    // or LONGPATHSOLVED if the solution exists but longer than the path length
    pathPlannerResult.setResult(Result::LONGPATHSOLVED);
    // or LONGPATHUNSOLVED if no solution exists even the search range was linger than the maximum
    // path length
    pathPlannerResult.setResult(Result::LONGPATHUNSOLVED);
  } else if (maxPathLength > 0 && cancelAtMaximum == true) {
    // Use heuristic function to calculate distances

    // pathPlannerResult.paths = doSomething(map.map) ;

    pathPlannerResult.setResult(Result::SOLVED);
    // or UNSOLVED if no path is found
    pathPlannerResult.setResult(Result::UNSOLVED);
  }
}
